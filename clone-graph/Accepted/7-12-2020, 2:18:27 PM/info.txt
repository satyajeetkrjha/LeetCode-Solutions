{"id":365681517,"lang":"cpp","time":"2 years, 1 month","timestamp":1594577907,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/365681517/","is_pending":"Not Pending","title":"Clone Graph","memory":"8.6 MB","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    \n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    \n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    \n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if(node == NULL)\n            return node;\n        unordered_map<Node*,Node*> m;\n        queue<Node*>q ;\n        q.push(node);\n        m[node]=new Node(node->val);\n        while(!q.empty()){\n            Node* cur_node=q.front();\n            q.pop();\n            for(auto nei:cur_node->neighbors){\n                if(!m[nei]){ // node has already been created corresponding to old node\n                    m[nei] =new Node(nei->val);\n                    q.push(nei);\n                }\n                m[cur_node]->neighbors.push_back(m[nei]);\n            }\n        }\n        return m[node];\n    }\n};","compare_result":"111111111111111111111","title_slug":"clone-graph"}