{"id":515860578,"lang":"cpp","time":"1 year, 1 month","timestamp":1625147135,"status_display":"Accepted","runtime":"200 ms","url":"/submissions/detail/515860578/","is_pending":"Not Pending","title":"Connecting Cities With Minimum Cost","memory":"45.8 MB","code":"class Solution {\npublic:\n    static bool comp( vector <int> &a , vector <int> &b){\n        return a[2]< b[2];\n    }\n    int find(vector <int> &parent,int i){\n        while(parent[i]!=i){\n            i = parent[i];\n        }\n        return i;\n    }\n    int minimumCost(int n, vector<vector<int>>& connections) {\n      sort(connections.begin(),connections.end(),comp);\n      int nodes =0;\n      int cost =0;\n       vector <int> parent(n+2,0);\n        for(int i =0;i<n+2;i++){\n            parent[i]=i;\n        }\n      for(int i =0;i<connections.size();i++){\n          vector <int> vec  = connections[i];\n          int u = vec[0];int v= vec[1];int w = vec[2];\n          int root1 =find(parent ,u);\n          int root2 = find(parent ,v);\n          if(root1 != root2){ // not going to form a cycle so include this in mst\n              cost+=w;\n              parent[root1]=root2;\n              nodes++;\n          }\n          if(nodes == n-1) return cost;\n      }  \n     return -1;   \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111","title_slug":"connecting-cities-with-minimum-cost"}