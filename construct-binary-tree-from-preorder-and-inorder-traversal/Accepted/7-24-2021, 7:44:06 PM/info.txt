{"id":527772936,"lang":"cpp","time":"1 year, 1 month","timestamp":1627170246,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/527772936/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    map <int ,int> m;\n    TreeNode* build (vector<int>& preorder, vector<int>& inorder ,int &rootIndex ,int start ,int end){\n      if(start > end){\n          return NULL ;\n      }\n      int elem = preorder[rootIndex]; // this gives the root\n      int index = m[elem];   // find index of that root in inorder traversal \n      TreeNode* root = new TreeNode(elem) ;// construct root with the elem \n      rootIndex++;\n      // now build left subtree and right subtree \n      root->left = build(preorder ,inorder,rootIndex, start,index-1);\n      root->right =  build(preorder ,inorder,rootIndex, index+1,end);\n        return root ;\n        \n        \n        \n    }\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        \n        int n = inorder.size();\n        for(int i =0 ;i<inorder.size();i++){\n            m[inorder[i]] = i ;\n        }\n        int rootIndex =0;\n        int start =0 ;int end = n-1;\n        return build(preorder ,inorder ,rootIndex,start,end);\n    \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}