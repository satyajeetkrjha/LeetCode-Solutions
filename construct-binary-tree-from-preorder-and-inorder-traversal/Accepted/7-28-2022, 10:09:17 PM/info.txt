{"id":759490934,"lang":"cpp","time":"3 weeks, 6 days","timestamp":1659060557,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/759490934/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.6 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    map <int ,int> m ;\n    \n    vector <int> preorder,inorder ;\n    TreeNode* buildTree(int &rootIndex,int start,int end){\n        if(start > end) return NULL;\n        int elem = preorder[rootIndex];\n        int index = m[elem];\n        TreeNode* root = new TreeNode(elem);\n        //cout <<\"Before :\"<< rootIndex << endl;\n        rootIndex++;\n        //cout <<\"After :\" << rootIndex << endl;\n        root->left = buildTree(rootIndex,start,index-1);\n        root->right = buildTree(rootIndex,index+1,end);\n        return root;\n        \n        \n    }\n    TreeNode* buildTree(vector<int>& preorder1, vector<int>& inorder1) {\n        preorder = preorder1;\n        inorder = inorder1 ;\n        \n        for(int i =  0 ;i<inorder.size();i++){\n          int x = inorder[i];\n          m[x] = i ;\n        }\n        \n        int rootIndex =0;\n        return buildTree(rootIndex,0,inorder.size()-1);\n        \n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}