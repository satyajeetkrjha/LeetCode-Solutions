{"id":527159248,"lang":"cpp","time":"1Â year, 1Â month","timestamp":1627060994,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/527159248/","is_pending":"Not Pending","title":"Convert Binary Search Tree to Sorted Doubly Linked List","memory":"7.5 MB","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n        left = NULL;\n        right = NULL;\n    }\n\n    Node(int _val, Node* _left, Node* _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* head =NULL;\n    Node* tail =NULL;\n    \n    void dfs(Node* root){\n        if(!root) return ;\n        dfs(root->left);\n        // work on node and this is where we work on node in inorder traversal\n        if(!head){\n            head = root ; // this is the leftmost node of the tree at bootom and will serve to be our leading node\n        }\n        else { // we are at a node that is not the depthmost in left .think \n            // this time our root is now 2 so we connect root 2 with tail 1\n            root->left = tail ;\n            tail->right = root ;\n            \n        }\n        tail = root ; // we made the current root as tail before recursion\n        \n        \n        dfs(root->right);\n    }\n    \n    Node* treeToDoublyList(Node* root) {\n        if(!root) return NULL;\n        dfs(root);\n        head->left = tail ;\n        tail->right = head ;\n        return head;\n        \n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"convert-binary-search-tree-to-sorted-doubly-linked-list"}