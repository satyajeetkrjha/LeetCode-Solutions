{"id":618473977,"lang":"cpp","time":"7 months, 2 weeks","timestamp":1642011587,"status_display":"Accepted","runtime":"465 ms","url":"/submissions/detail/618473977/","is_pending":"Not Pending","title":"Cutting Ribbons","memory":"92.5 MB","code":"/*\nlow = some value that's guaranteed to work\nhigh = some value that's guaranteed to not work\nWhile high-low>1 (\nmid=(high+low)/2\nIf mid works low = mid\nelse high = mid\n)\nTake any binary search problem and think invariant\nGeneral rule is, you are getting to find the boundary b where some f(x) is true only when x<=b\nJust set some x'<=b to be low, some x'>b to be high and update low=mid if f(mid) is true\nHaven't seen a single binary search problem where this won't work\n*/\n\n\nclass Solution {\npublic:\n    int maxLength(vector<int>& ribbons, int k) {\n        \n        int low = 0 ;\n        int high = INT_MIN;\n        \n        for(int i = 0 ;i<ribbons.size();i++){\n            high = max(high,ribbons[i]);\n        }\n        high=high+1;\n        while(high-low >1){\n            int mid =(low+high)/2;\n             int count =0 ;\n            for(int i =0 ;i<ribbons.size();i++){\n                count += ribbons[i]/mid;\n            }\n            if(count>=k){\n                low = mid;\n            }\n            else{\n              high =mid;\n            }\n        }\n        return low ;\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"cutting-ribbons"}