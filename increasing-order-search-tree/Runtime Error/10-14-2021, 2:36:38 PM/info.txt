{"id":571244133,"lang":"cpp","time":"10 months, 2 weeks","timestamp":1634236598,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/571244133/","is_pending":"Not Pending","title":"Increasing Order Search Tree","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    void inorder(TreeNode* root ,vector <TreeNode*> &v){\n        if(root == NULL)\n            return ;\n        inorder(root->left,v);\n        v.push_back(root); // don't push the value of root and instead push the root \n        inorder(root->right,v);\n    }\n    \n    TreeNode* increasingBST(TreeNode* root) {\n        // create a vector of TreeNodes \n        vector <TreeNode*> v;\n        inorder(root,v);\n        \n        // we now have all nodes of the tree in increasing order \n        for(int i =0 ;i<v.size();i++){\n            v[i]->left= NULL;\n            v[i]->right = v[i+1]; // at right side ,u put the entire node \n        }\n        v[v.size()-1]->right = NULL;\n        v[v.size()-1]->left =NULL;\n        return v[0];\n        \n        \n    }\n};","compare_result":"1100000000000000000000000000000000000","title_slug":"increasing-order-search-tree"}