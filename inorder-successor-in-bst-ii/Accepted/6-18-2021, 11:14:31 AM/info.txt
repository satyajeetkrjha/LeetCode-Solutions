{"id":509740694,"lang":"cpp","time":"1 year, 2 months","timestamp":1624029271,"status_display":"Accepted","runtime":"20 ms","url":"/submissions/detail/509740694/","is_pending":"Not Pending","title":"Inorder Successor in BST II","memory":"11.5 MB","code":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* left;\n    Node* right;\n    Node* parent;\n};\n*/\n\nclass Solution {\npublic:\n    Node* inorderSuccessor(Node* node) {\n        // case 1 when successor is in the downside tree\n        if(node ->right){\n            // first go to right \n            node = node ->right ;\n            // now go as left as you can \n            while(node ->left){\n                node = node ->left;\n            }\n            return node ;\n            \n        }\n        // case 2 find the first ancestor which is a left child\n        \n        //keep going up as long as u are the right child .when u can't gp up because u are no more the right child ,return the parent\n        while( node ->parent && node == node ->parent->right){\n            node = node ->parent;\n        }\n        return node->parent;\n    }\n};","compare_result":"11111111111111111111111111","title_slug":"inorder-successor-in-bst-ii"}