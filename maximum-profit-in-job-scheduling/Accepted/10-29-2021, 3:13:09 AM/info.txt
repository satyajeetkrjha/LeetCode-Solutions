{"id":578929970,"lang":"cpp","time":"10Â months","timestamp":1635491589,"status_display":"Accepted","runtime":"164 ms","url":"/submissions/detail/578929970/","is_pending":"Not Pending","title":"Maximum Profit in Job Scheduling","memory":"64.9 MB","code":"class Solution {\npublic:\n    // maximum number of jobs are 50000\n    int memo[50001];\n    \n    int findMaxProfit(vector<vector<int>>& jobs, vector<int>& start, int n, int position) {\n        // 0 profit if we have already iterated over all the jobs\n        if (position == n) {\n            return 0;\n        }\n        // we have already calculated the answer so no need to go into recursion\n        if (memo[position] != -1) {\n            return memo[position];\n        }\n        // nextIndex is the index of next non-conflicting job\n        // this step is similar to the binary search as in the java solution\n        // lower_bound will return the iterator to the first element which is \n        // equal to or greater than the element at `jobs[position][1]`\n        int nextIndex = lower_bound(start.begin(), start.end(), jobs[position][1]) - start.begin();\n        \n        // find the maximum profit of our two options: skipping or scheduling the current job\n        int maxProfit = max(findMaxProfit(jobs, start, n, position + 1), \n                        jobs[position][2] + findMaxProfit(jobs, start, n, nextIndex));\n        \n        // returning maximum profit and also storing it for future reference (memoization)\n        return memo[position] = maxProfit;\n    }\n    \n    int jobScheduling(vector<int>& startTime, vector<int>& endTime, vector<int>& profit) {\n        vector<vector<int>> jobs;\n        // marking all values to -1 so that we can differentiate \n        // if we have already calculated the answer or not\n        memset(memo, -1, sizeof(memo));\n        \n        // storing job's details into one list \n        // this will help in sorting the jobs while maintaining the other parameters\n        for (int i = 0; i < profit.size(); i++) {\n            jobs.push_back({startTime[i], endTime[i], profit[i]});\n        }\n        \n        sort(jobs.begin(), jobs.end());\n\n        // binary search will be used in startTime so store it as separate list\n        for (int i = 0; i < profit.size(); i++) {\n            startTime[i] = jobs[i][0];\n        }\n        \n        return findMaxProfit(jobs, startTime, profit.size(), 0);\n    }\n};","compare_result":"111111111111111111111111111","title_slug":"maximum-profit-in-job-scheduling"}