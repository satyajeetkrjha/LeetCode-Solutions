{"id":368234282,"lang":"cpp","time":"2 years, 1 month","timestamp":1595076165,"status_display":"Runtime Error","runtime":"N/A","url":"/submissions/detail/368234282/","is_pending":"Not Pending","title":"Maximum Width of Binary Tree","memory":"N/A","code":"// this code has been taken from a comment section\n\nclass Solution {\npublic:\n    int widthOfBinaryTree(TreeNode* root) {\n        if(!root)return 0;  \n        queue<pair<TreeNode*,int>>q;   // queue containg all pairs in a level\n        q.push({root,1});        // push the root node with position 1\n        int ans = 1;             //min width will be 1\n        while(!q.empty()){\n            int sz = q.size();      // get number of nodes in current level\n            int minval = INT_MAX,maxval = 0;\n            while(sz--){     // for all nodes in this level\n                auto node = q.front();q.pop();     // get the pair\n                int x = node.second*2;      // to calculate position\t\n\t\t\t\tif(node.first->left){    \n                    q.push({node.first->left,x});\n                    minval = min(minval,x);\n                    maxval = max(maxval,x);\n                }\n                if(node.first->right){\n                    q.push({node.first->right, x - 1 });\n                    minval = min(minval,x-1);\n                    maxval = max(maxval,x-1);\n                }\n            }\n // in case there were no children added set minval to 0  as maxval is already 0\n            minval = (minval == INT_MAX) ? 0 : minval; \n            ans = max((maxval - minval+1),ans);\n        }\n        return ans;\n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000","title_slug":"maximum-width-of-binary-tree"}