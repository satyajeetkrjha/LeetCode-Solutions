{"id":368229101,"lang":"cpp","time":"2 years, 1 month","timestamp":1595074829,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/368229101/","is_pending":"Not Pending","title":"Maximum Width of Binary Tree","memory":"N/A","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n#include <deque>\nclass Solution {\npublic:\n    int widthOfBinaryTree(TreeNode* root) {\n        if(root ==NULL)\n            return 0;\n        deque <TreeNode*> dq;\n        dq.push_back(root);\n        int ans = INT_MIN;\n        while(!dq.empty()){\n            // remove boundary element at the front of dequeue\n            while(!dq.empty() && dq.front() ==NULL){\n                dq.pop_front();\n            }\n             // remove boundary element at the end of dequeue\n            while(!dq.empty() && dq.back() ==NULL)\n            {\n                dq.pop_back();\n            }\n            int sz =dq.size(); // take size after all removals \n            ans = max(ans ,sz);\n            for(int i=0;i<sz;i++){\n                TreeNode* cur =dq.front();\n                dq.pop_front();\n                if(cur ==NULL){ // null nodes which exists between good nodes\n                    dq.push_back(NULL);\n                    dq.push_back(NULL); \n                }\n                else{ ///\n                    dq.push_back(cur->left);\n                    dq.push_back(cur->right);\n                }\n                   \n            }\n        }\n            return ans;        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111100000000000000000","title_slug":"maximum-width-of-binary-tree"}