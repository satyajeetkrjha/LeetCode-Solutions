{"id":570119033,"lang":"cpp","time":"10 months, 2 weeks","timestamp":1634059020,"status_display":"Accepted","runtime":"254 ms","url":"/submissions/detail/570119033/","is_pending":"Not Pending","title":"Path with Maximum Probability","memory":"66.2 MB","code":"#include <iomanip>\ntypedef pair <double ,int> pr ;\ndouble dist[100005];\nclass Solution {\npublic:\n    \n    void dijkistra(vector<vector <pair<int,double>>> &graph,int start ,int end){\n        priority_queue <pr> pq;\n        pq.push({1,start});\n        memset(dist,INT_MIN,sizeof(dist));\n        dist[start]=1;\n        while(!pq.empty()){\n            pr cur = pq.top();\n            pq.pop();\n            double w = cur.first ;\n            int u = cur.second;\n            for(auto nei:graph[u]){\n                int v = nei.first;\n                double d = nei.second;\n                if(dist[v]<d*w){\n                    dist[v] = d*w;\n                    pq.push({dist[v],v});\n                }\n            }\n        }\n        \n    }\n    \n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {\n        vector<vector <pair<int,double>>> graph ;\n        graph.resize(n);\n        for(int i =0 ;i<edges.size();i++){\n            int u = edges[i][0];int v = edges[i][1];double w = succProb[i];\n            graph[u].push_back({v,w});\n            graph[v].push_back({u,w});\n            \n        }\n         dijkistra(graph,start,end);\n        if(dist[end] == INT_MAX){\n            return 0.00000;\n        }\n        else{\n            return dist[end];\n        }\n        \n    }\n};","compare_result":"1111111111111111","title_slug":"path-with-maximum-probability"}