{"id":723704320,"lang":"cpp","time":"2 months, 1 week","timestamp":1655389028,"status_display":"Accepted","runtime":"408 ms","url":"/submissions/detail/723704320/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"63.8 MB","code":"class Solution {\n    \npublic:\n    vector <int> adj[2005];\n    bool bfs (vector <int> &color,int u){\n        queue <int> q ;\n        q.push(u);\n        color[u] = 0;\n        \n        while(!q.empty()){\n            auto cur = q.front();\n            q.pop();\n            for(auto neigh :adj[cur]){\n                if(color[neigh] ==-1){\n                    color[neigh] = 1 - color[cur];\n                    q.push(neigh);\n                }\n                else if (color[neigh] == color[cur]){\n                    return false ;\n                }\n            }\n        }\n        return true ;\n    }\n    \n    \n\n    \n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        \n        int sz = dislikes.size();\n        \n        for(int i =0 ;i< sz;i++){\n            int u = dislikes[i][0] ;int v = dislikes[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        \n        vector <int> color(n+2,-1);\n        \n        bool isbipartite= true;\n        for(int i =1 ;i<=n;i++){\n            if(color[i] == -1){\n                if(bfs(color,i) == false){\n                    isbipartite = false;\n                    break;\n                }\n            }\n        }\n        \n        return isbipartite ;\n        \n        \n        \n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"possible-bipartition"}