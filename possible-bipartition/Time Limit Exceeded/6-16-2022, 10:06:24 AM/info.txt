{"id":723697999,"lang":"cpp","time":"2 months, 1 week","timestamp":1655388384,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/723697999/","is_pending":"Not Pending","title":"Possible Bipartition","memory":"N/A","code":"class Solution {\n    \npublic:\n    vector <int> adj[2005];\n    bool bfs (vector <int> &color,int u){\n        queue <int> q ;\n        q.push(u);\n        color[u] = 0;\n        \n        while(!q.empty()){\n            auto cur = q.front();\n            q.pop();\n            for(auto &neigh :adj[cur]){\n                if(color[neigh] == color[cur]){\n                    return false;\n                }\n                else {\n                    q.push(neigh);\n                    color[neigh] = 1 - color[cur];\n                }\n            }\n        }\n        return true ;\n    }\n    \n    \n\n    \n    bool possibleBipartition(int n, vector<vector<int>>& dislikes) {\n        \n        int sz = dislikes.size();\n        \n        for(int i =0 ;i< sz;i++){\n            int u = dislikes[i][0] ;int v = dislikes[i][1];\n            adj[u].push_back(v);\n            adj[v].push_back(u);\n        }\n        \n        vector <int> color(n+1,-1);\n        \n        bool isbipartite= true;\n        for(int i =0 ;i< n;i++){\n            if(color[i] == -1){\n                if(bfs(color,i) == false){\n                    isbipartite = false;\n                    break;\n                }\n            }\n        }\n        \n        return isbipartite ;\n        \n        \n        \n        \n    }\n};","compare_result":"0000000000000000000000000000000000000000000000000000000000000000000000","title_slug":"possible-bipartition"}