{"id":526604478,"lang":"cpp","time":"1 year, 1 month","timestamp":1626967444,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/526604478/","is_pending":"Not Pending","title":"Robot Room Cleaner","memory":"8.4 MB","code":"/**\n * // This is the robot's control interface.\n * // You should not implement it, or speculate about its implementation\n * class Robot {\n *   public:\n *     // Returns true if the cell in front is open and robot moves into the cell.\n *     // Returns false if the cell in front is blocked and robot stays in the current cell.\n *     bool move();\n *\n *     // Robot will stay in the same cell after calling turnLeft/turnRight.\n *     // Each turn will be 90 degrees.\n *     void turnLeft();\n *     void turnRight();\n *\n *     // Clean the current cell.\n *     void clean();\n * };\n */\n\nclass Solution {\npublic:\n   vector<vector<int>> directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n    set <pair <int,int> > visited ;\n    \n    \n   void backtrack(Robot& robot, int i ,int j ,int dir){\n        visited.insert(make_pair(i ,j));\n        robot.clean();\n        for(int k =0 ;k<4;k++){\n            int newdir = (dir+k)%4 ;\n            \n            int newr = i + directions[newdir][0];\n            int newc = j + directions[newdir][1];\n            if(visited.find(make_pair(newr,newc)) == visited.end() && robot.move()){\n                backtrack(robot ,newr,newc,newdir);\n                // go back part\n                 robot.turnRight();\n                 robot.turnRight();\n                 robot.move();\n                 robot.turnRight();\n                 robot.turnRight();\n                // over\n            }\n            robot.turnRight();   \n        }\n    }\n    \n    void cleanRoom(Robot& robot) {\n        backtrack(robot, 0 ,0, 0); // Robot, i, j and direction \n    }\n};","compare_result":"11111111111111111111111111111","title_slug":"robot-room-cleaner"}