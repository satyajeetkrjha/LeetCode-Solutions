{"id":603773187,"lang":"cpp","time":"8 months, 1 week","timestamp":1639878485,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/603773187/","is_pending":"Not Pending","title":"Shortest Distance from All Buildings","memory":"N/A","code":"class Solution {\nprivate:\n    int bfs(vector<vector<int>>& grid, int row, int col, int totalHouses) {\n        // Next four directions.\n        int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        \n        int rows = grid.size();\n        int cols = grid[0].size();\n        int distanceSum = 0;\n        int housesReached = 0;\n\n        // Queue to do a bfs, starting from (r,c) cell\n        queue<pair<int, int>> q;\n        q.push({ row, col });\n\n        // Keep track of visited cells\n        vector<vector<bool>> vis(rows, vector<bool> (cols, false));\n        vis[row][col] = true;\n\n        int steps = 0;\n\n        while (!q.empty() && housesReached != totalHouses) {\n            for (int i = q.size(); i > 0; --i) {\n                auto curr = q.front();\n                q.pop();\n\n                row = curr.first;\n                col = curr.second;\n\n                // If this cell is a house, then add the distance from the source to this cell\n                // and we go past from this cell.\n                if (grid[row][col] == 1) {\n                    distanceSum += steps;\n                    housesReached++;\n                    continue;\n                }\n\n                // This cell was an empty cell, hence traverse the next cells which is not a blockage.\n                for (auto& dir : dirs) {\n                    int nextRow = row + dir[0];\n                    int nextCol = col + dir[1];\n\n                    if (nextRow >= 0 && nextCol >= 0 && nextRow < rows && nextCol < cols) {\n                        if (!vis[nextRow][nextCol] && grid[nextRow][nextCol] != 2) {\n                            vis[nextRow][nextCol] = true;\n                            q.push({nextRow, nextCol});\n                        }\n                    }\n                }\n            }\n            \n            // After traversing one level cells, increment the steps by 1 to reach to next level.\n            steps++;\n        }\n\n        // If we did not reach all houses, then any cell visited also cannot reach all houses.\n        // Set all cells visted to 2 so we do not check them again and return INT_MAX.\n        if (housesReached != totalHouses) {\n            for (row = 0; row < rows; row++) {\n                for (col = 0; col < cols; col++) {\n                    if (grid[row][col] == 0 && vis[row][col]) {\n                        grid[row][col] = 2;\n                    }\n                }\n            }\n            return INT_MAX;\n        }\n        // If we have reached all houses then return the total distance calculated.\n        return distanceSum;\n    }\n\npublic:\n    int shortestDistance(vector<vector<int>>& grid) {\n        int minDistance = INT_MAX;\n        int rows = grid.size();\n        int cols = grid[0].size();\n        int totalHouses = 0;\n\n        for (int row = 0; row < rows; ++row) {\n            for (int col = 0; col < cols; ++col) {\n                if (grid[row][col] == 1) { \n                    totalHouses++;\n                }\n            }\n        }\n\n        // Find the min distance sum for each empty cell.\n        for (int row = 0; row < rows; ++row) {\n            for (int col = 0; col < cols; ++col) {\n                if (grid[row][col] == 0) {\n                    minDistance = min(minDistance, bfs(grid, row, col, totalHouses));\n                }\n            }\n        }\n\n        // If it is impossible to reach all houses from any empty cell, then return -1.\n        if (minDistance == INT_MAX) {\n            return -1;\n        }\n        return minDistance;\n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-distance-from-all-buildings"}