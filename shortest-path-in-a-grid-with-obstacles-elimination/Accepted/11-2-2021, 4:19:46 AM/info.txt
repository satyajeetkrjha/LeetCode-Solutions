{"id":580894846,"lang":"cpp","time":"9 months, 3 weeks","timestamp":1635841186,"status_display":"Accepted","runtime":"88 ms","url":"/submissions/detail/580894846/","is_pending":"Not Pending","title":"Shortest Path in a Grid with Obstacles Elimination","memory":"31.8 MB","code":"class Solution {\npublic:\n  int shortestPath(vector<vector<int>>& grid, int k) {\n    int m = grid.size(), n=grid[0].size(); if(m==1 and n==1) return 0;\n    \n      //dist[i][j][k] = minimum distance to (i,j) such that k obstacles can still be removed\n    vector<vector<vector<int>>> dist(m, vector<vector<int>>(n, vector<int>(k+1, -1)));\n    dist[0][0][k] = 0;\n    queue<tuple<int,int,int>> bfsq;\n    bfsq.push({0,0,k});\n    \n    int neigh[4][2]{{0,1},{1,0},{0,-1},{-1,0}};\n    while(!bfsq.empty()){\n      auto [i,j,rem] = bfsq.front(); bfsq.pop();\n      for(auto [di,dj]: neigh) {\n        int ii = i+di, jj = j+dj, rrem;\n        if(ii >=0 and ii<m and jj>=0 and jj<n and (rrem = rem - grid[ii][jj])>=0 and dist[ii][jj][rrem]==-1) {\n          dist[ii][jj][rrem] = dist[i][j][rem] + 1;\n          if(ii==m-1 and jj == n-1) return dist[ii][jj][rrem];\n          bfsq.push({ii,jj,rrem});\n        }\n      }\n    }\n    return -1;\n  }\n};","compare_result":"1111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-in-a-grid-with-obstacles-elimination"}