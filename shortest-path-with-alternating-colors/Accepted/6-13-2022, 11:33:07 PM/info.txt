{"id":721728868,"lang":"cpp","time":"2 months, 1 week","timestamp":1655177587,"status_display":"Accepted","runtime":"26 ms","url":"/submissions/detail/721728868/","is_pending":"Not Pending","title":"Shortest Path with Alternating Colors","memory":"14.3 MB","code":"class Solution {\npublic:\n    vector<int> shortestAlternatingPaths(int n, vector<vector<int>>& redEdges, vector<vector<int>>& blueEdges) {\n        \n        vector <int> adjred[n];\n        vector <int> adjblue[n];\n        \n       for(int i =0;i<redEdges.size();i++){\n            int u = redEdges[i][0];\n            int v = redEdges[i][1];\n            adjred[u].push_back(v);\n        }\n        \n        for(int i =0 ;i<blueEdges.size() ;i++){\n            int u = blueEdges[i][0];\n            int v = blueEdges[i][1];\n            adjblue[u].push_back(v);\n        }\n        \n        queue <pair <int ,int> > q ;\n        \n        q.push({0,1});\n        q.push({0,-1});\n        \n        vector <pair <int ,int> > res ;\n        res.resize(n,{INT_MAX,INT_MAX});\n        res[0] = {0,0} ; // hey ya \n        \n        int dist =0 ;\n        while(!q.empty()){\n            int sz = q.size();\n            for(int i =0 ;i< sz;i++){\n                auto [node,color]= q.front();\n                q.pop();\n                if(color == 1){\n                    for(auto neigh :adjblue[node]){\n                        if(res[neigh].second > dist +1){\n                            res[neigh].second = dist+1;\n                            q.push({neigh,-1});\n                        }\n                    }\n                }\n                else {\n                    for(auto neigh :adjred[node]){\n                        if(res[neigh].first > dist +1){\n                            res[neigh].first= dist +1;\n                            q.push({neigh,1});\n                        }\n                    }\n                }\n            }\n            dist++;\n        }\n        \n        \n      vector <int> ans ;\n        for(int i =0 ;i< n;i++){\n            int val = min(res[i].first ,res[i].second);\n            if(val == INT_MAX)\n                val = -1;\n            ans.push_back(val);\n        }\n        \n        \n        \n        \n        \n        return ans ;\n        \n        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"shortest-path-with-alternating-colors"}