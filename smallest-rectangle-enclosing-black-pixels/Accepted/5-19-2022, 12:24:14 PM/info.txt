{"id":702864107,"lang":"cpp","time":"3 months, 1 week","timestamp":1652977454,"status_display":"Accepted","runtime":"63 ms","url":"/submissions/detail/702864107/","is_pending":"Not Pending","title":"Smallest Rectangle Enclosing Black Pixels","memory":"16.6 MB","code":"class Solution {\npublic:\n    int minX ,minY ,maxX,maxY ;\n \n    \n    void dfs (vector<vector<char>>& image ,int x ,int y){\n        if( x >= image.size() || x <0 || y >= image[0].size() || y < 0 || image[x][y] == '0')\n            return ;\n        \n        image[x][y] ='0';\n        \n        minX = min(minX,x);\n        minY= min(minY,y);\n        maxX = max(maxX,x);\n        maxY = max(maxY,y);\n        \n        dfs(image ,x+1,y);\n        dfs(image ,x-1,y);\n        dfs(image,x,y+1);\n        dfs(image ,x,y-1);\n        \n        \n    }\n    \n    \n    int minArea(vector<vector<char>>& image, int x, int y) {\n        \n        /* x and y is one of the black pixel of the only connected component*/\n         minX=image.size() -1;\n         maxX=0;\n         minY =image[0].size()-1;\n         maxY= 0;\n         dfs(image ,x,y);\n         return (maxX-minX+1)*(maxY-minY+1);\n        \n        \n        \n    }\n};","compare_result":"111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-rectangle-enclosing-black-pixels"}