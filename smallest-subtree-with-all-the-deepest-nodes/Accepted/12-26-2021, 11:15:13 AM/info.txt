{"id":607484072,"lang":"cpp","time":"8Â months","timestamp":1640535313,"status_display":"Accepted","runtime":"8 ms","url":"/submissions/detail/607484072/","is_pending":"Not Pending","title":"Smallest Subtree with all the Deepest Nodes","memory":"14.4 MB","code":"class Solution {\npublic:\n    TreeNode* lca( TreeNode* root, TreeNode* p, TreeNode* q ) {\n        if ( !root || root == p || root == q ) return root;\n        TreeNode *left = lca( root->left, p, q );\n        TreeNode *right = lca (root->right, p, q );\n\n        return !left? right: !right? left: root;\n    }\n    \n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        if ( !root || !root->left && !root->right ) return root;\n        TreeNode *leftMost = NULL;\n        TreeNode *rightMost = NULL;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        while( !q.empty() ) {\n            int levelSize = q.size();\n            for(int level = 0; level < levelSize; level++ ) {\n                TreeNode* node = q.front(); q.pop();\n                if ( level == 0 ) leftMost = node;\n                if ( level == levelSize - 1 ) rightMost = node;\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n                \n            }\n        }\n        return lca( root, leftMost, rightMost );\n    }\n};\n","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-subtree-with-all-the-deepest-nodes"}