{"id":607484492,"lang":"cpp","time":"8Â months","timestamp":1640535376,"status_display":"Accepted","runtime":"4 ms","url":"/submissions/detail/607484492/","is_pending":"Not Pending","title":"Smallest Subtree with all the Deepest Nodes","memory":"14.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    \n    TreeNode* lca(TreeNode * root ,TreeNode* p ,TreeNode* q){\n        if(!root || root == p || root == q)\n            return root ;\n        TreeNode* left = lca(root->left ,p,q);\n        TreeNode* right = lca(root->right,p,q);\n        \n        return !left? right: !right? left: root;\n    }\n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        if(!root){\n            return root ;\n        }\n        TreeNode* leftmost = NULL;\n        TreeNode* rightmost = NULL;\n        \n        queue <TreeNode*> q;\n        q.push(root);\n        \n        while(!q.empty()){\n            int sz = q.size();\n            for(int i =0 ;i<sz;i++){\n                TreeNode* curr = q.front();\n                q.pop();\n                if( i == 0) leftmost = curr ;\n                if(i == sz-1) rightmost = curr ;\n                if(curr->left) q.push(curr->left);\n                if(curr->right) q.push(curr->right);\n            }   \n        }\n        \n        return lca (root ,leftmost ,rightmost);\n        \n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111","title_slug":"smallest-subtree-with-all-the-deepest-nodes"}