{"id":718551429,"lang":"cpp","time":"2 months, 2 weeks","timestamp":1654829358,"status_display":"Accepted","runtime":"1039 ms","url":"/submissions/detail/718551429/","is_pending":"Not Pending","title":"Stock Price Fluctuation ","memory":"168.6 MB","code":"\n/*\nThink Satya think .\nwe are going to use a map <int ,int>m and this is going to store the price against timestamp .\nWe use a multiset too but why ? Note that a multiset can contain duplicates .\nSo this may be the situation \nat timestamp 1 -> 10 \nagain timestmap 1 -> 15\nso you will delette 10 because 15 is the new one .\nbut hey it can be that two timestamps have same price \ni.e. timestamp 1 = 10\n     timestamp 2 = 10\n\n\n\n\n\n*/\n\n\n\n\nclass StockPrice {\npublic:\n    map <int ,int> m ;\n    multiset <int> prices;\n    int latest = -1;\n    StockPrice() {\n        \n    }\n    \n    void update(int timestamp, int price) {\n        // check if we already have this timestamp mapped \n        if(m.count(timestamp)>0){\n            prices.erase(prices.find(m[timestamp]));\n        }\n        m[timestamp] = price;\n        latest = max(latest,timestamp);\n        prices.insert(price);\n    }\n    \n    int current() {\n        return m[latest];\n    }\n    \n    int maximum() {\n        return *prices.rbegin();\n    }\n    \n    int minimum() {\n        return  *prices.begin();\n    }\n};\n\n/**\n * Your StockPrice object will be instantiated and called as such:\n * StockPrice* obj = new StockPrice();\n * obj->update(timestamp,price);\n * int param_2 = obj->current();\n * int param_3 = obj->maximum();\n * int param_4 = obj->minimum();\n */","compare_result":"111111111111111111","title_slug":"stock-price-fluctuation"}