{"id":511794756,"lang":"cpp","time":"1 year, 2 months","timestamp":1624400833,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/511794756/","is_pending":"Not Pending","title":"The Maze","memory":"N/A","code":"class Solution {\npublic:\n    bool hasPath(vector<vector<int>>& maze, vector<int>& start, vector<int>& destination) {\n        int R = maze.size();\n        int C = maze[0].size();\n        int visited[R+1][C+1];\n        for(int i=0;i<R;i++){\n            for(int j=0;j<C;j++){\n                visited[i][j] = 0 ;\n            }\n        }\n        int dx[4] ={0,0,-1,1};\n        int dy[4] ={1,-1,0,0};\n        queue <pair <int,int> > q;\n        q.push(make_pair(start[0],start[1]));\n        visited[start[0]][start[1]] = 1;\n        while(!q.empty()){\n            pair <int ,int> cur = q.front();\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nr = cur.first+dx[i];\n                int nc = cur.second+dy[i];\n                // within the reach and should not be visited and should not be a wall\n                if(nr  >=0 && nr <R && nc >=0 && nc <C && maze[nr][nc] == 0 && !visited[nr][nc]){\n                   if(nr == destination[0] && nc == destination[1]){\n                       return true;\n                   }\n                    q.push(make_pair(nr,nc));\n                    visited[nr][nc] =1;\n                }\n            }   \n        }\n                          return false ;\n        \n        \n        \n        \n    }\n};","compare_result":"100011110010111011011110101011111111011000000011111111111111111111111010001001","title_slug":"the-maze"}