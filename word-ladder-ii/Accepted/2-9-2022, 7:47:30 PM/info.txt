{"id":638225627,"lang":"cpp","time":"6 months, 2 weeks","timestamp":1644454050,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/638225627/","is_pending":"Not Pending","title":"Word Ladder II","memory":"9.7 MB","code":"class Solution {\npublic:\n    \n    map <string,vector<string> > adjlist;\n    vector <string> currpath ;\n    vector <vector <string> > shortestpaths ;\n    \n    vector<string> findNeighbours(string &word ,unordered_set <string> &wordlist){\n        \n        vector <string> neighbours ;\n        for(int i =0 ;i<word.size();i++){\n            char oldchar = word[i];\n            for (char c = 'a';c<='z';c++){\n                word[i] = c;\n                if( c == oldchar || !wordlist.count(word)){\n                    continue;\n                }\n                neighbours.push_back(word);\n            }\n            word[i] = oldchar;\n        }\n        return neighbours ;\n        \n    }\n    \n    void backtrack(string &source ,string &destination){\n        if(source == destination){\n            shortestpaths.push_back(currpath);\n        }\n        for(int i =0 ;i< adjlist[source].size();i++){\n            currpath.push_back(adjlist[source][i]);\n            backtrack(adjlist[source][i],destination);\n            currpath.pop_back();\n        }\n    }\n    \n    \n    \n    void bfs(string beginWord,string endWord ,unordered_set<string>&wordList){\n        \n        queue <string> q;\n        q.push(beginWord);\n        \n        // remove the root word\n        if(wordList.find(beginWord) != wordList.end()){\n            wordList.erase(wordList.find(beginWord));\n        }\n        \n        map <string ,int> isEnqueued;\n        isEnqueued[beginWord] = 1;\n        \n        while(!q.empty()){\n            vector <string> visited ;\n            int sz = q.size();\n            for(int i =0 ;i<sz;i++){\n                string currword = q.front();\n                q.pop();\n                vector <string> neighbours = findNeighbours(currword,wordList);\n                for(auto word:neighbours){\n                    visited.push_back(word);\n                    adjlist[currword].push_back(word);\n                    if(isEnqueued.find(word) == isEnqueued.end()){\n                        q.push(word);\n                        isEnqueued[word] =1 ;\n                    }\n                }\n            }\n            for(int i =0 ;i< visited.size();i++){\n                if(wordList.find(visited[i])!=wordList.end()){\n                    wordList.erase(wordList.find(visited[i]));\n                }\n            }\n        }\n    }\n    \n    \n    \n    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n        \n        unordered_set <string> copiedWords(wordList.begin(),wordList.end());\n        \n        bfs(beginWord,endWord,copiedWords);\n        \n        currpath = {beginWord};\n        backtrack(beginWord,endWord);\n        \n        return shortestpaths ;\n        \n        \n    }\n};","compare_result":"11111111111111111111111111111111","title_slug":"word-ladder-ii"}